// Generated by CoffeeScript 1.3.3
var ass;

ass = {};

if (!Detector.webgl) {
  Detector.addGetWebGLMessage();
}

ass.initThreeJS = function() {
  var color, fieldSize, i, particles, size, sprite, sprite1, vertex, _i, _j, _ref;
  ass.mouseX = 0;
  ass.mouseY = 0;
  ass.windowHalfX = window.innerWidth / 2;
  ass.windowHalfY = window.innerHeight / 2;
  ass.container = document.createElement('div');
  document.body.appendChild(ass.container);
  ass.scene = new THREE.Scene();
  ass.scene.fog = new THREE.FogExp2(0x000000, 0.0008);
  ass.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 4000);
  ass.camera.position.z = 2000;
  ass.scene.add(ass.camera);
  ass.geometry = new THREE.Geometry();
  fieldSize = 3000;
  for (i = _i = 0; _i <= 1000; i = ++_i) {
    vertex = new THREE.Vector3();
    vertex.x = Math.random() * fieldSize - fieldSize * 0.5;
    vertex.y = Math.random() * fieldSize - fieldSize * 0.5;
    vertex.z = Math.random() * fieldSize - fieldSize * 0.5;
    ass.geometry.vertices.push(vertex);
  }
  sprite1 = THREE.ImageUtils.loadTexture('img/particle.png');
  ass.parameters = [[[1.0, 0.2, 1.0], sprite1, 20], [[0.95, 0.1, 1], sprite1, 15], [[0.90, 0.05, 1], sprite1, 10], [[0.85, 0, 0.8], sprite1, 8], [[0.80, 0, 0.7], sprite1, 5]];
  ass.materials = [];
  for (i = _j = 0, _ref = ass.parameters.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
    color = ass.parameters[i][0];
    sprite = ass.parameters[i][1];
    size = ass.parameters[i][2];
    ass.materials[i] = new THREE.ParticleBasicMaterial({
      size: size,
      map: sprite,
      blending: THREE.AdditiveBlending,
      depthTest: false,
      transparent: true
    });
    ass.materials[i].color.setHSV(color[0], color[1], color[2]);
    particles = new THREE.ParticleSystem(ass.geometry, ass.materials[i]);
    particles.rotation.x = Math.random() * 6;
    particles.rotation.y = Math.random() * 6;
    particles.rotation.z = Math.random() * 6;
    ass.scene.add(particles);
  }
  ass.renderer = new THREE.WebGLRenderer({
    clearAlpha: 1
  });
  ass.renderer.setSize(window.innerWidth, window.innerHeight);
  ass.container.appendChild(ass.renderer.domElement);
  ass.stats = new Stats();
  ass.stats.domElement.style.position = "absolute";
  ass.stats.domElement.style.top = "0px";
  ass.container.appendChild(ass.stats.domElement);
  document.addEventListener("mousemove", ass.onDocumentMouseMove, false);
  document.addEventListener("touchstart", ass.onDocumentTouchStart, false);
  document.addEventListener("touchmove", ass.onDocumentTouchMove, false);
  window.addEventListener("resize", ass.onWindowResize, false);
  ass.elapsedTime = 0.0;
  ass.time = Date.now() * 0.00005;
  return ass.lastTime = ass.time;
};

ass.onWindowResize = function() {
  ass.windowHalfX = window.innerWidth / 2;
  ass.windowHalfY = window.innerHeight / 2;
  ass.camera.aspect = window.innerWidth / window.innerHeight;
  ass.camera.updateProjectionMatrix();
  return ass.renderer.setSize(window.innerWidth, window.innerHeight);
};

ass.onDocumentMouseMove = function(event) {
  ass.mouseX = event.clientX - ass.windowHalfX;
  return ass.mouseY = event.clientY - ass.windowHalfY;
};

ass.onDocumentTouchStart = function(event) {
  if (event.touches.length === 1) {
    event.preventDefault();
    ass.mouseX = event.touches[0].pageX - ass.windowHalfX;
    return ass.mouseY = event.touches[0].pageY - ass.windowHalfY;
  }
};

ass.onDocumentTouchMove = function(event) {
  if (event.touches.length === 1) {
    event.preventDefault();
    ass.mouseX = event.touches[0].pageX - ass.windowHalfX;
    return ass.mouseY = event.touches[0].pageY - ass.windowHalfY;
  }
};

ass.animate = function() {
  requestAnimationFrame(ass.animate);
  ass.render();
  return ass.stats.update();
};

ass.render = function() {
  var camera, color, h, i, object, s, scene, _i, _j, _ref, _ref1;
  ass.lastTime = ass.time;
  ass.time = Date.now() * 0.00005;
  ass.deltaTime = ass.time - ass.lastTime;
  ass.elapsedTime += ass.deltaTime;
  camera = ass.camera;
  scene = ass.scene;
  camera.position.x += (ass.mouseX - camera.position.x) * 0.05;
  camera.position.y += (-ass.mouseY - camera.position.y) * 0.05;
  camera.lookAt(scene.position);
  for (i = _i = 0, _ref = scene.children.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    object = scene.children[i];
    if (object instanceof THREE.ParticleSystem) {
      s = 1.0 + Math.abs(Math.sin(ass.elapsedTime * 50)) * 0.5;
      object.scale.set(1, 1, s);
      object.rotation.y = ass.time * (i < 4 ? i + 1 : -(i + 1));
    }
  }
  for (i = _j = 0, _ref1 = ass.materials.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
    color = ass.parameters[i][0];
    h = (360 * (color[0] + ass.time) % 360) / 360;
    ass.materials[i].color.setHSV(h, color[1], color[2]);
  }
  return ass.renderer.render(scene, camera);
};

ass.init = function() {
  var angle, angleStr, canvas, center, context, l, radius;
  canvas = $("#shakecanvas")[0];
  context = canvas.getContext('2d');
  angle = Math.floor(Math.random() * 360) * 1.0;
  center = 32.0;
  radius = 30.0;
  l = ass.getCircleCoordinates(center, center, radius, angle);
  context.beginPath();
  context.moveTo(center, center);
  context.lineTo(l.x, l.y);
  context.strokeStyle = '#ff0000';
  context.stroke();
  context.beginPath();
  context.arc(center, center, radius, 0, 2 * Math.PI, false);
  context.stroke();
  angleStr = 'rotate(' + angle + 'deg)';
  return $('.item').css({
    '-transform': angleStr,
    '-ms-transform': angleStr,
    '-moz-transform': angleStr,
    '-webkit-transform': angleStr,
    '-o-transform': angleStr
  }).html(angle);
};

ass.getCircleCoordinates = function(x, y, radius, angle) {
  var result;
  result = {};
  result.x = x + radius * Math.cos(angle * Math.PI / 180.0);
  result.y = y - radius * Math.sin(angle * Math.PI / 180.0);
  return result;
};

$(document).ready(function() {
  if (!Detector.webgl) {
    Detector.addGetWebGLMessage();
  }
  ass.init();
  ass.initThreeJS();
  return ass.animate();
});
